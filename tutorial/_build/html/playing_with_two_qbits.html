

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Playing with a two-qbit system &mdash; DMRG101 tutorial 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="DMRG101 tutorial 0.1 documentation" href="index.html" />
    <link rel="next" title="Heisenberg model for two spins" href="heisenberg_model_for_two_spins.html" />
    <link rel="prev" title="How to use the tutorial" href="how_to_use_the_tutorial.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="heisenberg_model_for_two_spins.html" title="Heisenberg model for two spins"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="how_to_use_the_tutorial.html" title="How to use the tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">DMRG101 tutorial 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="playing-with-a-two-qbit-system">
<h1>Playing with a two-qbit system<a class="headerlink" href="#playing-with-a-two-qbit-system" title="Permalink to this headline">¶</a></h1>
<p>The goal of this exercise is to build the wavefunction of a pair of spins
one-half (a.k.a. a pair of qbits), and calculate its entanglement
entropy. This is a pretty trivial exercise that you could do without much
hassle in a piece of paper (see below.) The purpose is just get you
familiar with how things are done in the code before moving to bigger
adventures.</p>
<div class="section" id="exercise">
<h2>Exercise<a class="headerlink" href="#exercise" title="Permalink to this headline">¶</a></h2>
<p>Calculate the entanglement entropy when you trace out one of the spins in
a general state in the spin zero subspace of a two spin one-half system.
For which of the states in the spin zero subspace is are the two spin
maximally entangled (i.e. the Von Neumann entanglement entropy is
maximal)?</p>
</div>
<div class="section" id="hint">
<h2>Hint<a class="headerlink" href="#hint" title="Permalink to this headline">¶</a></h2>
<p>The first thing we need to do is to write the wavefunction of the two spin
system. In dmrg101 the wavefunctions are represented as matrices instead
of vectors, which may be more familiar to you.</p>
<p>The reason for that is that as in DMRG we always have to split the
physical systems (say a chain of spins, or the two spins of the problem)
in left and right subsystems, the notation with matrices is more suited.
In the dmrg101 code the rows of the matrix representing a wavefunction
correspond to states of the left subsystem, and the columns correspond to
states of the right subsystem.</p>
<p>For example to represent the two spin one-half system, with one spin as
left subsystem and the other as right subsystem, we need a 2x2 matrix.
Matrix elements in the first row (column) will correspond to states with
the left (right) spin down.  Matrix elements in the second row (column)
will correspond to states with the left (right) spin up. The choice of
whether the first or second row corresponds to spin down or up is
arbitrary, but once you made the choice you have to be consistent.</p>
<p>If we restrict ourselves to the <img class="math" src="_images/math/351c301ddaff7f4a558adc00d5885e8966eadd0c.png" alt="S_{tot}=0"/> subspace, the most general
wavefunction for the two qbit systems is simply <a class="footnote-reference" href="#id2" id="id1">[1]</a>:</p>
<div class="math">
<p><img src="_images/math/517d1326ea8699206cd3cc1a24d809f5de7285c7.png" alt="|\psi\rangle = \cos \phi |\downarrow\uparrow\rangle
+ \sin \phi |\uparrow\downarrow\rangle =
\begin{pmatrix} 0 &amp; \cos \phi \\ \sin\phi &amp; 0 \end{pmatrix}"/></p>
</div></div>
<div class="section" id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Permalink to this headline">¶</a></h2>
<p>The plan is the following. First we are going to write a function to
calculate the wavefunction for the two-qbit system as a function of the
an angle <cite>psi</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">create_two_qbit_system_in_singlet</span><span class="p">(</span><span class="n">psi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the wf of the system as a function of `psi`.</span>

<span class="sd">    The (normalized) wavefunction of the two-qbit system can be</span>
<span class="sd">    parametrized as a function an angle `psi`. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psi : a double </span>
<span class="sd">        Parametrizes the wavefunction.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : a Wavefunction</span>
<span class="sd">        The wavefunction of the two-qbit system for the given `psi`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">Wavefunction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c"># set the different components.</span>
    <span class="n">result</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">result</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Now we are going to get the reduced density matrix tracing out the
left qbit and calculate the corresponding entanglement entropy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">trace_out_left_qbit_and_calculate_entropy</span><span class="p">(</span><span class="n">wf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the entropy after tracing out the left qbit.</span>

<span class="sd">    To calculate the entanglement entropy you need to first build the</span>
<span class="sd">    reduced density matrix tracing out the degrees of freedom of one of</span>
<span class="sd">    the two qbits (it does not matter which, we pick up left here.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wf : a Wavefunction</span>
<span class="sd">        The wavefunction you build up the reduced density matrix with.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : a double</span>
<span class="sd">        The value of the von Neumann entanglement entropy after tracing</span>
<span class="sd">	out the left qbit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reduced_DM_for_right_qbit</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">build_reduced_density_matrix</span><span class="p">(</span><span class="s">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">diagonalize</span><span class="p">(</span><span class="n">reduced_DM_for_right_qbit</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">calculate_entropy</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Now it just a matter to generate a bunch of different values for <cite>psi</cite>,
calculate the corresponding wavefunction with the first function above,
and pass the wavefunction to the second funciton above to get the value
for the entropy. The following code makes this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Calculates the entanglement entropy for a system of two qbits in a</span>
<span class="sd">    singlet state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># </span>
    <span class="c"># get a bunch of values (number_of_psi) for psi</span>
    <span class="c">#</span>
    <span class="n">number_of_psi</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">number_of_psi</span>
    <span class="n">psi_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">step</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_psi</span><span class="p">)]</span> 
    <span class="c">#</span>
    <span class="c"># python function map applies a function to a sequence</span>
    <span class="c">#</span>
    <span class="n">wfs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">create_two_qbit_system_in_singlet</span><span class="p">,</span> <span class="n">psi_values</span><span class="p">)</span>
    <span class="n">entropies</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">trace_out_left_qbit_and_calculate_entropy</span><span class="p">,</span> <span class="n">wfs</span><span class="p">)</span>
    <span class="c"># </span>
    <span class="c"># find to which value of psi corresponds the max entropy</span>
    <span class="c">#</span>
    <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">psi_values</span><span class="p">,</span> <span class="n">entropies</span><span class="p">)</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c"># </span>
    <span class="c"># print the results</span>
    <span class="c">#</span>
    <span class="k">print</span> <span class="s">&quot;The maximum value for entropy is </span><span class="si">%8.6f</span><span class="s">.&quot;</span> <span class="o">%</span><span class="n">max_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;The wavefunction with max entropy is: &quot;</span>
    <span class="k">print</span> <span class="n">create_two_qbit_system_in_singlet</span><span class="p">(</span><span class="n">max_value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_matrix</span>
    <span class="c">#</span>
    <span class="c"># save for plotting</span>
    <span class="c">#</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;two_qbit_entropies.dat&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;The whole list of psi vs entropies is saved in&quot;</span><span class="p">,</span>
    <span class="k">print</span> <span class="n">filename</span><span class="o">+</span><span class="s">&#39;.&#39;</span>
</pre></div>
</div>
<p>See <a class="reference download internal" href="_downloads/two_qbit_system.py"><tt class="xref download docutils literal"><span class="pre">a</span> <span class="pre">full</span> <span class="pre">implementation</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">above</span> <span class="pre">code</span></tt></a>. If you run that code you should
get something like this:</p>
<div class="highlight-python"><pre>(dmrg101) $ python tutorial/solutions/two_qbit_system.py
The maximum value for entropy is 0.693147.
The wavefunction with max entropy is:
[[ 0.          0.70710678]
 [ 0.70710678  0.        ]]
The whole list of psi vs entropies is saved in two_qbit_entropies.dat.</pre>
</div>
<p>Which is are in fact the entropy (<img class="math" src="_images/math/41b49e84af3d024b84d84097a8f253e2e4128b9e.png" alt="log(2)"/>) and wavefunction of the
singlet. See also the <a class="reference download internal" href="_downloads/two_qbit_entropies.dat"><tt class="xref download docutils literal"><span class="pre">data</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">entropies</span> <span class="pre">vs</span> <span class="pre">psi</span></tt></a>.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>It is important that you note that this is the general solution for a
system of two qbits, and that two-qbits cannot be more entangled that in
the singlet state. In system of many particles is splitted in two parts
(think in a larger chain of spins cut at some point in two), one can
always represent the relevant degrees of freedom at the cut as a set of
qbits. Then it follows from the result you just proved that the most
<em>economical</em> way of representing the entanglement across the cut is to map
the degrees of freedom of each side to a qbits and <em>maximally entangle</em>
them across the cut. Any other state to be formed with the qbits in one
side and the other, will either have less entanglement across the cut than
the one in the original degrees of freedom, or use more qbits at each
side of the cut. This is the basis of the mappings used in quantum
information methods like MPS or TNS, and you will see <em>maximally entangled
spins/qbits</em> a lot in the rest of the school.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There could be an extra phase between the two components, but it
cancels out later, so we don&#8217;t bother to include it.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Playing with a two-qbit system</a><ul>
<li><a class="reference internal" href="#exercise">Exercise</a></li>
<li><a class="reference internal" href="#hint">Hint</a></li>
<li><a class="reference internal" href="#solution">Solution</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="how_to_use_the_tutorial.html"
                        title="previous chapter">How to use the tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="heisenberg_model_for_two_spins.html"
                        title="next chapter">Heisenberg model for two spins</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/playing_with_two_qbits.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="heisenberg_model_for_two_spins.html" title="Heisenberg model for two spins"
             >next</a> |</li>
        <li class="right" >
          <a href="how_to_use_the_tutorial.html" title="How to use the tutorial"
             >previous</a> |</li>
        <li><a href="index.html">DMRG101 tutorial 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Ivan Gonzalez.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>